/**
 * 微信小程序音频工具类
 * 使用 wx.createInnerAudioContext() 播放音频
 */

const { pianoKeyMapping } = require('./pianoKeyMapping.js')
const audioDownloadManager = require('./audioDownloadManager.js')

class AudioManager {
  constructor() {
    this.audioPool = new Map() // 音频对象池
    this.isAudioEnabled = true
    this.maxAudioInstances = 15 // 增加最大同时播放数量
    this.preloadLevel = 'common' // 预加载级别: essential, common, extended, full
    this.hasUserInteraction = false // 记录是否有用户交互
    this.isWarmedUp = false // 记录是否已预热
    
    // 音符频率映射（扩展到88键）
    this.noteFrequencies = this.generateNoteFrequencies()
    
    this.init()
  }

  // 生成88键钢琴音符频率映射
  generateNoteFrequencies() {
    const frequencies = {}
    const fullRange = pianoKeyMapping.getFullRange()
    
    // A4 = 440Hz作为参考，计算其他音符频率
    const A4_FREQ = 440
    const A4_INDEX = pianoKeyMapping.getFileByNoteKey('a4').index
    
    Object.entries(fullRange).forEach(([noteKey, noteInfo]) => {
      // 计算与A4的半音距离
      const semitonesFromA4 = noteInfo.index - A4_INDEX
      // 频率公式: f = f0 * 2^(n/12)
      const frequency = A4_FREQ * Math.pow(2, semitonesFromA4 / 12)
      frequencies[noteKey] = Math.round(frequency * 100) / 100 // 保留2位小数
    })
    
    return frequencies
  }

  // 初始化音频管理器
  init() {
    console.log('🎵 音频管理器初始化 (支持88键钢琴)')
    
    // 检查音频权限
    this.checkAudioPermission()
    
    // 初始化音频上下文
    this.initAudioContext()
    
    // 根据预加载级别预加载音符
    this.preloadNotesByLevel()
    
    // 音频预热
    this.warmupAudio()
    
    // 延迟报告加载状态
    setTimeout(() => {
      this.reportLoadingStatus()
    }, 2000)
  }

  // 初始化音频上下文（解决真机播放问题）
  initAudioContext() {
    // 创建一个静音音频来激活音频上下文
    try {
      const audio = wx.createInnerAudioContext()
      audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LHdSEFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAcBzuVz+zGbyECLHXE7+5VGQs' 
      audio.volume = 0
      audio.play()
      audio.onEnded(() => {
        audio.destroy()
      })
      console.log('音频上下文初始化成功')
    } catch (error) {
      console.warn('音频上下文初始化失败:', error)
    }
  }

  // 检查音频权限
  checkAudioPermission() {
    wx.getSetting({
      success: (res) => {
        console.log('音频权限检查完成')
        
        // 检查是否需要授权
        if (res.authSetting['scope.record'] === false) {
          console.warn('用户拒绝了录音权限，可能影响音频播放')
        }
      },
      fail: (error) => {
        console.warn('权限检查失败:', error)
      }
    })
  }

  // 根据级别预加载音符
  preloadNotesByLevel() {
    const suggestions = pianoKeyMapping.getPreloadSuggestions()
    let notesToPreload = []
    
    switch (this.preloadLevel) {
      case 'essential':
        notesToPreload = suggestions.essential
        console.log('🎹 预加载核心音符 (8个):', notesToPreload)
        break
      case 'common':
        notesToPreload = Object.keys(suggestions.common)
        console.log('🎹 预加载常用音符 (36个):', notesToPreload.slice(0, 10), '...等')
        break
      case 'extended':
        notesToPreload = Object.keys(suggestions.extended)
        console.log('🎹 预加载扩展音符 (73个):', notesToPreload.slice(0, 10), '...等')
        break
      case 'full':
        notesToPreload = Object.keys(suggestions.full)
        console.log('🎹 预加载全部音符 (88个):', notesToPreload.slice(0, 10), '...等')
        break
      default:
        notesToPreload = suggestions.essential
        console.log('🎹 默认预加载核心音符:', notesToPreload)
    }
    
    // 验证音符列表
    const invalidNotes = notesToPreload.filter(noteKey => 
      !noteKey || !noteKey.match(/^[a-g]#?[0-8]$/)
    )
    
    if (invalidNotes.length > 0) {
      console.error('❌ 发现无效的预加载音符:', invalidNotes)
      // 过滤掉无效音符
      notesToPreload = notesToPreload.filter(noteKey => 
        noteKey && noteKey.match(/^[a-g]#?[0-8]$/)
      )
    }
    
    console.log(`📝 实际预加载音符数量: ${notesToPreload.length}`)
    
    // 分批预加载，避免一次性加载过多
    this.batchPreload(notesToPreload)
  }

  // 分批预加载音符
  batchPreload(noteKeys, batchSize = 10, delay = 100) {
    const batches = []
    for (let i = 0; i < noteKeys.length; i += batchSize) {
      batches.push(noteKeys.slice(i, i + batchSize))
    }
    
    batches.forEach((batch, index) => {
      setTimeout(() => {
        batch.forEach(noteKey => {
          this.preloadNote(noteKey)
        })
        console.log(`🎵 预加载批次 ${index + 1}/${batches.length} 完成`)
      }, index * delay)
    })
  }

  // 预加载单个音符
  preloadNote(noteKey) {
    return new Promise((resolve) => {
      if (this.audioPool.has(noteKey)) {
        console.log(`音符 ${noteKey} 已预加载`)
        resolve(this.audioPool.get(noteKey))
        return
      }

      console.log(`🎵 开始预加载音符: ${noteKey}`)

      // 验证音符键名格式
      if (!noteKey || typeof noteKey !== 'string' || !noteKey.match(/^[a-g]#?[0-8]$/)) {
        console.error(`❌ 无效的音符键名格式: "${noteKey}"`)
        this.audioPool.set(noteKey, null)
        resolve(null)
        return
      }

      const audioUrl = this.getAudioUrl(noteKey)
      
      // 如果没有音频文件，直接标记为无音频模式
      if (!audioUrl) {
        this.audioPool.set(noteKey, null)
        console.log(`音符 ${noteKey} 使用振动模式`)
        resolve(null)
        return
      }

      // 特殊处理：如果是带#号的音符且URL包含#号，先尝试创建安全副本
      if (noteKey.includes('#') && audioUrl.includes('#')) {
        console.log(`🔧 检测到带#号音符，尝试安全处理: ${noteKey}`)
        
        // 先尝试获取安全副本路径
        const audioDownloadManager = require('./audioDownloadManager')
        const safePath = audioDownloadManager.createSafeFileCopy(audioUrl, noteKey)
        
        if (safePath && safePath !== audioUrl) {
          console.log(`🎯 使用安全副本路径: ${noteKey} -> ${safePath}`)
          this.preloadNoteWithUrl(noteKey, safePath).then(resolve)
          return
        }
      }

      this.preloadNoteWithUrl(noteKey, audioUrl).then(resolve)
    })
  },

  // 使用指定URL预加载音符
  preloadNoteWithUrl(noteKey, audioUrl) {
    return new Promise((resolve) => {
      console.log(`🎵 音符 ${noteKey} 音频URL: ${audioUrl}`)

      // 创建音频实例
      const audio = wx.createInnerAudioContext()
      
      audio.src = audioUrl
      
      // 设置音频属性
      audio.volume = 0.8
      audio.loop = false
      audio.autoplay = false
      
      // 添加超时检测
      let loadTimeout = null
      let isLoaded = false
      let isResolved = false
      
      const resolveOnce = (result) => {
        if (!isResolved) {
          isResolved = true
          resolve(result)
        }
      }
      
      // 错误处理
      audio.onError((error) => {
        console.warn(`音频加载失败 ${noteKey}:`, error)
        clearTimeout(loadTimeout)
        
        // 分析错误类型
        let errorType = 'unknown'
        if (error.errMsg && error.errMsg.includes('Unable to decode audio data')) {
          errorType = 'decode_error'
          console.error(`🚫 音频解码失败 ${noteKey}: 文件可能损坏或格式不支持`)
          
          // 解码错误：标记为永久失败，不再重试
          this.audioPool.set(noteKey, null)
          console.log(`⚠️ 音符 ${noteKey} 永久使用振动反馈 (解码失败)`)
          resolveOnce(null)
          return
          
        } else if (error.errMsg && error.errMsg.includes('404')) {
          errorType = 'file_not_found'
          console.error(`📁 音频文件不存在 ${noteKey}: ${audioUrl}`)
        } else if (error.errMsg && error.errMsg.includes('network')) {
          errorType = 'network_error'
          console.error(`🌐 网络错误 ${noteKey}: 无法下载音频文件`)
        }
        
        // 只对非解码错误进行重试，且限制重试次数
        if (!isLoaded && errorType !== 'decode_error') {
          const retryCount = this.audioPool.get(noteKey + '_retry_count') || 0
          if (retryCount < 2) { // 最多重试2次
            console.log(`🔄 尝试重新加载音符: ${noteKey} (重试 ${retryCount + 1}/2)`)
            this.audioPool.set(noteKey + '_retry_count', retryCount + 1)
            setTimeout(async () => {
              try {
                const result = await this.retryPreloadNote(noteKey)
                resolveOnce(result)
              } catch (retryError) {
                this.audioPool.set(noteKey, null)
                resolveOnce(null)
              }
            }, 1000 * (retryCount + 1)) // 递增延迟
          } else {
            console.log(`❌ 音符 ${noteKey} 重试次数已用完，使用振动反馈`)
            this.audioPool.set(noteKey, null)
            resolveOnce(null)
          }
        } else {
          console.log(`⚠️ 音符 ${noteKey} 将使用振动反馈 (错误类型: ${errorType})`)
          this.audioPool.set(noteKey, null)
          resolveOnce(null)
        }
      })
      
      // 音频加载完成
      audio.onCanplay(() => {
        isLoaded = true
        clearTimeout(loadTimeout)
        
        // 清除重试计数
        this.audioPool.delete(noteKey + '_retry_count')
        
        // 只在详细模式下记录
        if (this.preloadLevel === 'essential') {
          console.log(`音频预加载完成: ${noteKey}`)
        }
        
        resolveOnce(audio)
      })
      
      // 设置加载超时（5秒）
      loadTimeout = setTimeout(() => {
        if (!isLoaded && !isResolved) {
          console.warn(`音频加载超时 ${noteKey}`)
          audio.destroy()
          this.audioPool.set(noteKey, null)
          resolveOnce(null)
        }
      }, 5000)
      
      this.audioPool.set(noteKey, audio)
    })
  },

  // 重试预加载音符
  retryPreloadNote(noteKey) {
    console.log(`重试预加载音符: ${noteKey}`)
    
    // 清除旧的实例
    const oldAudio = this.audioPool.get(noteKey)
    if (oldAudio && typeof oldAudio.destroy === 'function') {
      oldAudio.destroy()
    }
    this.audioPool.delete(noteKey)
    
    // 重新预加载
    const audioUrl = this.getAudioUrl(noteKey)
    if (!audioUrl) {
      this.audioPool.set(noteKey, null)
      return
    }

    const audio = wx.createInnerAudioContext()
    audio.src = audioUrl
    audio.volume = 0.8
    audio.loop = false
    audio.autoplay = false
    
    // 简化的错误处理（不再重试）
    audio.onError((error) => {
      console.warn(`音频重试仍然失败 ${noteKey}:`, error)
      this.audioPool.set(noteKey, null)
    })
    
    audio.onCanplay(() => {
      console.log(`音频重试成功 ${noteKey}`)
    })
    
    this.audioPool.set(noteKey, audio)
  },

  // 获取音频文件URL
  getAudioUrl(noteKey) {
    // 验证音符是否在88键范围内
    const noteInfo = pianoKeyMapping.getFileByNoteKey(noteKey)
    if (!noteInfo) {
      console.warn(`无效音符: ${noteKey}`)
      return null
    }
    
    // 优先使用下载的音频文件
    const localPath = audioDownloadManager.getLocalAudioPath(noteKey)
    if (localPath) {
      // 验证路径是否完整（包含文件扩展名）
      if (!localPath.includes('.mp3')) {
        console.error(`❌ 音频路径不完整: ${noteKey} -> ${localPath}`)
        return null
      }
      
      // 验证路径是否包含正确的音符名
      const expectedFileName = `${noteKey}.mp3`
      if (!localPath.includes(expectedFileName)) {
        console.error(`❌ 音频路径不匹配: ${noteKey} 期望 ${expectedFileName} 但得到 ${localPath}`)
        return null
      }
      
      console.log(`使用下载的音频文件: ${noteKey} -> ${localPath}`)
      return localPath
    }
    
    // 如果没有下载的文件，直接返回null，使用振动反馈
    console.warn(`音频文件未下载: ${noteKey}，将使用振动反馈`)
    return null
  },

  // 播放音符
  playNote(noteKey, options = {}) {
    if (!this.isAudioEnabled) {
      console.log('音频已禁用')
      return
    }

    // 在用户交互时重新激活音频上下文
    if (!this.hasUserInteraction) {
      this.hasUserInteraction = true
      this.reactivateAudioContext()
    }

    const {
      volume = 0.8,
      duration = 500,
      fadeOut = true,
      retry = true
    } = options

    console.log(`播放音符: ${noteKey}`)

    // 检查是否是已知的永久失败音符
    const retryCount = this.audioPool.get(noteKey + '_retry_count') || 0
    if (retryCount >= 2) {
      console.log(`🚫 跳过播放永久失败的音符: ${noteKey}，直接使用振动`)
      this.playVibrateNote(noteKey)
      return
    }

    // 获取或创建音频实例
    let audio = this.audioPool.get(noteKey)
    if (audio === undefined) {
      // 动态加载未预加载的音符
      this.preloadNote(noteKey)
      audio = this.audioPool.get(noteKey)
    }

    // 如果是null，表示使用振动模式
    if (audio === null) {
      this.playVibrateNote(noteKey)
      return
    }

    // 如果仍然没有音频实例，回退到振动
    if (!audio) {
      console.warn(`音频实例创建失败: ${noteKey}`)
      this.playVibrateNote(noteKey)
      return
    }

    try {
      // 重置音频状态
      audio.seek(0)
      
      // 设置音量
      audio.volume = volume
      
      // 设置错误处理
      audio.onError((error) => {
        console.warn(`音频播放出错 ${noteKey}:`, error)
        
        // 如果是解码错误，标记为永久失败
        if (error.errMsg && error.errMsg.includes('Unable to decode audio data')) {
          console.log(`🚫 播放时发现解码错误，标记为永久失败: ${noteKey}`)
          this.audioPool.set(noteKey + '_retry_count', 3) // 设置为超过重试上限
          this.audioPool.set(noteKey, null)
          this.playVibrateNote(noteKey)
          return
        }
        
        // 如果允许重试，尝试重新创建音频实例
        if (retry && retryCount < 2) {
          console.log(`重试播放音符: ${noteKey}`)
          this.audioPool.delete(noteKey) // 删除有问题的实例
          this.preloadNote(noteKey) // 重新创建
          
          // 递归调用，但不再重试
          setTimeout(() => {
            this.playNote(noteKey, { ...options, retry: false })
          }, 100)
        } else {
          // 最终回退到振动
          this.playVibrateNote(noteKey)
        }
      })
      
      // 开始播放
      audio.play()
      
      // 如果设置了持续时间，自动停止
      if (duration > 0) {
        setTimeout(() => {
          try {
            if (fadeOut) {
              this.fadeOutAudio(audio, 100)
            } else {
              audio.stop()
            }
          } catch (error) {
            console.warn(`停止音频失败 ${noteKey}:`, error)
          }
        }, duration)
      }
      
      // 同时提供触觉反馈
      this.playVibrateNote(noteKey)
      
    } catch (error) {
      console.error(`播放音符异常 ${noteKey}:`, error)
      
      // 如果允许重试
      if (retry && retryCount < 2) {
        console.log(`异常重试播放音符: ${noteKey}`)
        this.audioPool.delete(noteKey)
        this.preloadNote(noteKey)
        setTimeout(() => {
          this.playNote(noteKey, { ...options, retry: false })
        }, 100)
      } else {
        this.playVibrateNote(noteKey)
      }
    }
  },

  // 重新激活音频上下文（用户交互后）
  reactivateAudioContext() {
    console.log('🎵 用户交互，重新激活音频上下文')
    
    try {
      // 创建一个测试音频来激活上下文
      const testAudio = wx.createInnerAudioContext()
      testAudio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LHdSEFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAcBzuVz+zGbyECLHXE7+5VGQs'
      testAudio.volume = 0
      testAudio.play()
      
      testAudio.onEnded(() => {
        testAudio.destroy()
      })
      
      testAudio.onError(() => {
        testAudio.destroy()
      })
      
      // 重新加载失败的音频实例
      this.reloadFailedAudio()
      
    } catch (error) {
      console.warn('重新激活音频上下文失败:', error)
    }
  },

  // 重新加载失败的音频实例
  reloadFailedAudio() {
    const failedNotes = []
    const permanentlyFailedNotes = []
    
    // 找出标记为null（振动模式）的音符
    this.audioPool.forEach((audio, noteKey) => {
      if (audio === null) {
        // 检查是否是永久失败的音符（解码错误等）
        const retryCount = this.audioPool.get(noteKey + '_retry_count') || 0
        if (retryCount >= 2) {
          permanentlyFailedNotes.push(noteKey)
        } else {
          failedNotes.push(noteKey)
        }
      }
    })
    
    if (permanentlyFailedNotes.length > 0) {
      console.log(`🚫 跳过 ${permanentlyFailedNotes.length} 个永久失败的音频:`, permanentlyFailedNotes)
    }
    
    if (failedNotes.length > 0) {
      console.log(`🔄 重新加载 ${failedNotes.length} 个失败的音频:`, failedNotes)
      
      // 分类处理：带#号的音符和普通音符
      const sharpNotes = failedNotes.filter(note => note.includes('#'))
      const normalNotes = failedNotes.filter(note => !note.includes('#'))
      
      if (sharpNotes.length > 0) {
        console.log(`🎵 特别处理 ${sharpNotes.length} 个带#号的音符:`, sharpNotes)
      }
      
      failedNotes.forEach((noteKey, index) => {
        // 延迟加载，避免同时创建太多音频实例
        setTimeout(() => {
          // 清理旧的实例和重试计数
          this.audioPool.delete(noteKey)
          this.audioPool.delete(noteKey + '_retry_count')
          
          // 对带#号的音符，强制重新获取安全路径
          if (noteKey.includes('#')) {
            console.log(`🔧 重新处理带#号音符: ${noteKey}`)
          }
          
          this.preloadNote(noteKey)
        }, index * 300) // 增加延迟时间
      })
    } else {
      console.log(`✅ 没有需要重新加载的音频文件`)
    }
  },

  // 渐出效果
  fadeOutAudio(audio, duration = 200) {
    const startVolume = audio.volume
    const stepTime = 50
    const steps = duration / stepTime
    const volumeStep = startVolume / steps
    
    let currentStep = 0
    const fadeInterval = setInterval(() => {
      currentStep++
      const newVolume = Math.max(0, startVolume - (volumeStep * currentStep))
      audio.volume = newVolume
      
      if (currentStep >= steps || newVolume <= 0) {
        clearInterval(fadeInterval)
        audio.stop()
        audio.volume = startVolume // 恢复原始音量
      }
    }, stepTime)
  },

  // 使用振动模拟音符（备用方案）
  playVibrateNote(noteKey) {
    if (!noteKey) return
    
    const frequency = this.noteFrequencies[noteKey] || 440
    
    // 根据频率调整振动模式
    if (frequency < 130) {
      // 极低音 - 长振动
      wx.vibrateLong()
    } else if (frequency < 260) {
      // 低音 - 长振动
      wx.vibrateLong()
    } else if (frequency > 1000) {
      // 高音 - 短振动
      wx.vibrateShort()
    } else {
      // 中音 - 短振动
      wx.vibrateShort()
    }
  },

  // 播放和弦
  playChord(noteKeys, options = {}) {
    noteKeys.forEach((noteKey, index) => {
      setTimeout(() => {
        this.playNote(noteKey, options)
      }, index * 50) // 错开50ms播放
    })
  },

  // 播放音阶
  playScale(noteKeys, options = {}) {
    const { interval = 300 } = options
    
    noteKeys.forEach((noteKey, index) => {
      setTimeout(() => {
        this.playNote(noteKey, options)
      }, index * interval)
    })
  },

  // 设置预加载级别
  setPreloadLevel(level) {
    const validLevels = ['essential', 'common', 'extended', 'full']
    if (!validLevels.includes(level)) {
      console.warn('无效的预加载级别:', level)
      return
    }
    
    this.preloadLevel = level
    console.log(`设置预加载级别为: ${level}`)
    
    // 清理当前预加载的音频
    this.clearAudioPool()
    
    // 重新预加载
    this.preloadNotesByLevel()
  },

  // 清理音频池
  clearAudioPool() {
    this.audioPool.forEach((audio) => {
      if (audio && typeof audio.destroy === 'function') {
        audio.destroy()
      }
    })
    this.audioPool.clear()
  },

  // 停止所有音频
  stopAll() {
    this.audioPool.forEach((audio, noteKey) => {
      try {
        if (audio && typeof audio.stop === 'function') {
          audio.stop()
        }
      } catch (error) {
        console.warn(`停止音频失败 ${noteKey}:`, error)
      }
    })
  },

  // 设置全局音量
  setVolume(volume) {
    this.audioPool.forEach((audio) => {
      if (audio && typeof audio.volume !== 'undefined') {
        audio.volume = Math.max(0, Math.min(1, volume))
      }
    })
  },

  // 启用/禁用音频
  setAudioEnabled(enabled) {
    this.isAudioEnabled = enabled
    if (!enabled) {
      this.stopAll()
    }
    console.log(`音频${enabled ? '启用' : '禁用'}`)
  },

  // 销毁音频管理器
  destroy() {
    this.stopAll()
    this.clearAudioPool()
    console.log('音频管理器已销毁')
  },

  // 报告音频加载状态
  reportLoadingStatus() {
    console.log('=== 🎹 音频加载状态报告 ===')
    
    let audioCount = 0
    let vibrateCount = 0
    const suggestions = pianoKeyMapping.getPreloadSuggestions()
    
    this.audioPool.forEach((audio, noteKey) => {
      if (audio === null) {
        vibrateCount++
      } else if (audio) {
        audioCount++
      }
    })
    
    console.log(`📊 当前预加载级别: ${this.preloadLevel}`)
    console.log(`📊 音频文件: ${audioCount} 个`)
    console.log(`📊 振动模式: ${vibrateCount} 个`)
    console.log(`📊 总计预加载: ${this.audioPool.size} 个音符`)
    console.log(`📊 88键总数: ${Object.keys(suggestions.full).length} 个`)
    
    if (audioCount > 0) {
      console.log('🎉 音频文件加载成功！支持88键钢琴音效！')
    } else {
      console.log('ℹ️  当前使用振动反馈模式')
    }
    
    // 显示预加载级别说明
    console.log('\n💡 预加载级别说明:')
    console.log('- essential: 8个核心音符 (中央C区域)')
    console.log('- common: 36个常用音符 (C3-B5)')
    console.log('- extended: 73个扩展音符 (C2-C7)')
    console.log('- full: 88个完整音符 (A0-C8)')
  },

  // 获取音符信息
  getNoteInfo(noteKey) {
    return pianoKeyMapping.getFileByNoteKey(noteKey)
  },

  // 获取音符频率
  getNoteFrequency(noteKey) {
    return this.noteFrequencies[noteKey] || 440
  },

  // 健康检查和性能监控
  async performHealthCheck() {
    console.log('🔍 执行音频系统健康检查...')
    
    const checkResult = {
      audioContextActive: false,
      downloadManagerHealth: null,
      audioPoolStatus: null,
      recommendations: []
    }
    
    try {
      // 1. 检查音频上下文状态
      checkResult.audioContextActive = this.isAudioEnabled
      
      // 2. 检查下载管理器健康状态
      const audioDownloadManager = require('./audioDownloadManager')
      checkResult.downloadManagerHealth = await audioDownloadManager.performHealthCheck()
      
      // 3. 检查音频池状态
      checkResult.audioPoolStatus = this.getAudioPoolStatus()
      
      // 4. 生成建议
      if (checkResult.downloadManagerHealth.percentage < 80) {
        checkResult.recommendations.push('音频文件下载不完整，建议重新下载')
      }
      
      if (checkResult.audioPoolStatus.nullCount > 10) {
        checkResult.recommendations.push('过多音频实例创建失败，建议重新激活音频上下文')
      }
      
      if (!checkResult.audioContextActive) {
        checkResult.recommendations.push('音频上下文未激活，需要用户交互后重新激活')
      }
      
      console.log('📊 音频系统健康检查完成:', checkResult)
      return checkResult
      
    } catch (error) {
      console.error('音频系统健康检查失败:', error)
      checkResult.error = error.message
      return checkResult
    }
  },

  // 获取音频池状态
  getAudioPoolStatus() {
    let validCount = 0
    let nullCount = 0
    let errorCount = 0
    
    this.audioPool.forEach((audio, noteKey) => {
      if (audio === null) {
        nullCount++
      } else if (audio && typeof audio.play === 'function') {
        validCount++
      } else {
        errorCount++
      }
    })
    
    return {
      total: this.audioPool.size,
      valid: validCount,
      null: nullCount,
      error: errorCount,
      healthScore: Math.round((validCount / this.audioPool.size) * 100)
    }
  },

  // 智能修复音频系统
  async performSmartRepair() {
    console.log('🔧 开始智能修复音频系统...')
    
    const healthCheck = await this.performHealthCheck()
    const repairActions = []
    
    try {
      // 1. 修复下载管理器问题
      if (healthCheck.downloadManagerHealth && healthCheck.downloadManagerHealth.failed > 0) {
        console.log('🔄 修复音频下载问题...')
        const audioDownloadManager = require('./audioDownloadManager')
        await audioDownloadManager.retryFailedDownloads()
        repairActions.push('重新下载失败的音频文件')
      }
      
      // 2. 清理和重建音频池
      if (healthCheck.audioPoolStatus && healthCheck.audioPoolStatus.healthScore < 70) {
        console.log('🧹 清理并重建音频池...')
        this.clearAudioPool()
        await this.preloadNotesByLevel(2) // 重新预加载核心音符
        repairActions.push('重建音频实例池')
      }
      
      // 3. 重新激活音频上下文
      if (!healthCheck.audioContextActive) {
        console.log('🔄 重新激活音频上下文...')
        this.reactivateAudioContext()
        repairActions.push('重新激活音频上下文')
      }
      
      console.log('✅ 智能修复完成，执行的操作:', repairActions)
      return {
        success: true,
        actions: repairActions,
        healthCheck: await this.performHealthCheck() // 修复后重新检查
      }
      
    } catch (error) {
      console.error('❌ 智能修复失败:', error)
      return {
        success: false,
        error: error.message,
        actions: repairActions
      }
    }
  },

  // 性能监控
  getPerformanceStats() {
    const audioDownloadManager = require('./audioDownloadManager')
    const downloadStats = audioDownloadManager.getStats()
    const poolStatus = this.getAudioPoolStatus()
    
    return {
      downloadManager: downloadStats,
      audioPool: poolStatus,
      audioEnabled: this.isAudioEnabled,
      preloadLevel: this.preloadLevel,
      timestamp: new Date().toISOString(),
      overallHealth: this.calculateOverallHealth(downloadStats, poolStatus)
    }
  },

  // 计算总体健康度
  calculateOverallHealth(downloadStats, poolStatus) {
    const downloadHealth = downloadStats.progress.percentage || 0
    const poolHealth = poolStatus.healthScore || 0
    const contextHealth = this.isAudioEnabled ? 100 : 0
    
    const overallScore = Math.round((downloadHealth * 0.5 + poolHealth * 0.3 + contextHealth * 0.2))
    
    let status = 'excellent'
    if (overallScore < 60) status = 'poor'
    else if (overallScore < 80) status = 'fair'
    else if (overallScore < 90) status = 'good'
    
    return {
      score: overallScore,
      status: status,
      issues: this.identifyIssues(downloadStats, poolStatus)
    }
  },

  // 识别问题
  identifyIssues(downloadStats, poolStatus) {
    const issues = []
    
    if (downloadStats.progress.percentage < 80) {
      issues.push('音频文件下载不完整')
    }
    
    if (poolStatus.healthScore < 70) {
      issues.push('音频实例池健康度低')
    }
    
    if (!this.isAudioEnabled) {
      issues.push('音频上下文未激活')
    }
    
    if (downloadStats.successRate < 90) {
      issues.push('音频下载成功率低')
    }
    
    return issues
  },

  // 自动优化
  async autoOptimize() {
    console.log('⚡ 开始自动优化音频系统...')
    
    const stats = this.getPerformanceStats()
    const optimizations = []
    
    try {
      // 1. 如果健康度低，执行智能修复
      if (stats.overallHealth.score < 70) {
        console.log('🔧 健康度低，执行智能修复...')
        const repairResult = await this.performSmartRepair()
        if (repairResult.success) {
          optimizations.push('智能修复系统')
        }
      }
      
      // 2. 预加载优化
      const audioDownloadManager = require('./audioDownloadManager')
      if (stats.downloadManager.progress.success > 20) {
        console.log('⚡ 预加载高优先级音频...')
        await audioDownloadManager.preloadByPriority(8)
        optimizations.push('预加载高优先级音频')
      }
      
      // 3. 音频池优化
      if (stats.audioPool.healthScore < 90 && stats.audioPool.valid < 20) {
        console.log('🎵 扩展音频预加载...')
        await this.preloadNotesByLevel(3)
        optimizations.push('扩展音频预加载')
      }
      
      console.log('✅ 自动优化完成，执行的优化:', optimizations)
      return {
        success: true,
        optimizations: optimizations,
        finalStats: this.getPerformanceStats()
      }
      
    } catch (error) {
      console.error('❌ 自动优化失败:', error)
      return {
        success: false,
        error: error.message,
        optimizations: optimizations
      }
    }
  },

  // 音频预热 - 确保首次点击有声音
  warmupAudio() {
    console.log('🔥 开始音频预热...')
    
    // 延迟500ms后开始预热，确保下载管理器已初始化
    setTimeout(() => {
      // 预热最常用的几个音符
      const warmupNotes = ['c4', 'd4', 'e4', 'f4', 'g4']
      
      warmupNotes.forEach((noteKey, index) => {
        setTimeout(() => {
          this.preloadNote(noteKey).then((audio) => {
            if (audio && audio !== null) {
              console.log(`🎹 预热完成: ${noteKey}`)
            }
          }).catch(error => {
            console.log(`⚠️ 预热失败: ${noteKey}`, error)
          })
        }, index * 100) // 错开100ms
      })
      
      // 1.5秒后标记预热完成
      setTimeout(() => {
        this.isWarmedUp = true
        console.log('✅ 音频预热完成')
      }, 1500)
      
    }, 500)
  }
}

// 创建全局音频管理器实例
const audioManager = new AudioManager()

module.exports = {
  AudioManager,
  audioManager
} 